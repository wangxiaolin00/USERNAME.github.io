### 堆与堆排序
* 堆是一个数据结构
* 堆排序是用堆实现的排序算法
* 堆是一个完全二叉树
  因为堆是一个完全二叉树使用数组的形式存储,即节省空间,又因为节点间的数学关系,能够直接用公式或者递归推到出来,并且不会因为递归深度的问题爆栈
* 堆中 所有的结果总是比其子节点大或等 (小或等)
*  每一个节点大于等于其子节点的堆成为大顶堆
* 每一个节点小于等其子节点的成为小顶堆

* 研究只关心最值 或者部分最值的
* 堆使用数组结构 拿下标减一除以2 得到父元素
* 插入一个元素 ,自底向上调整 比上面的节点大就一直交换
* 堆的俩种操作
  往堆里增加一个元素
   先将新元素放入堆的末尾 先元素比父节点的元素大就一直往上换
  往堆里面删掉一个元素,只能删除堆定的元素,先把堆的元素放到堆顶,然后将子节点的较大者换上来直到  
效率就是log(n)
将一个随机分布的数组就地的调整为一个堆
方法一:按节点的顺序从前往后一次调整一个元素

方法二:从后往前,认为遇到的节点的都是正确的堆,自堆定向下调 效率为O(n)



最大堆:Max-Heap
   父节点的比子节点大
最小堆:父节点比子节点小

对于索引为k 的节点
 左节点为2k+1
 右节点为2k+2
 父节点为Math.floor(k/2)

倒数第一个分支节点的序号?
公共 Math.floor(n/2)个节点
可知倒数第一个分支节点的序号idx
 idx=n-Math.floor(n/2)-1
    =Math.floor(n/2)-1
