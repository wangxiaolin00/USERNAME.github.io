<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /*promise的理解与使用
     * promise 是JS中进行异步编程的新的解决方案(旧的是用 纯回调函数形式完成)
      
      从语法来说 Promise是一个构造函数
      从功能上述 Promise对象封装异步操作并获取其结果

       
     *
     *为什么要用promise?
     * 1.指定回调函数的方式更加灵活
     *    *旧的:必须在启动异步任务前指定
     *    * Promise:启动异步任务=> 返回promise 对象 =>给promise 对象绑定回调函数 (甚至可以在异步任务结束后指定多个)
     * 2. 支持链式调用 可以解决回调地域问题
     */

    /*什么是回调地狱
     * (函数作为参数 层层嵌套)
     *  如何解决回调地狱?
     *   保持代码简洁 (给函数起有意义的名字)
     * 模块化 函数封装 每个功能 都是独立的 ,可以单独的定义 一个js文件 Vue react 中通过import来引入
     *处理每一个错误
     *
     *
     */

   /*如何使用Promise
     Promise 构造函数:Promise(excutor){}
    (1)excutor 函数: 执行器 (resolve,reject)=>{}
    (2)resolve 函数 :内部定义成功时我们调用的函数value=>{}
    (3)reject 函数: 内部定义失败时我们调用reason=>{}

    说明 :excutor 会在promise 内部立即同步回调 异步操作 在执行器中执行

    Promise.prototype.then 方法:(onResolved,onRejected)=>{}
    

    Promise 状态 改变
     一开始new 出来的时候是pending 状态
     pending 变为 resolved 成功状态
     pending 变为 rejected  失败状态
     说明 只会变成这俩种状态
        且一个promise 对象只能改变一次
        无论变成成功还是失败 都会有一个结果 数据
        成功的结果数据一般称为 value 失败的结果数据为 reason
    
    /


  </script>
  
</body>
</html>